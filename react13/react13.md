## 知識課題 1

フロントエンド開発における状態（State）とは何か、あなたの言葉で説明してください。
アプリケーションのユーザーインターフェース（UI）の表示内容や挙動を決める変化するデータのこと。画面の今を表す、アプリにとっての“心拍”のような存在

なぜ状態管理（State Management）が、現代の Web アプリケーション開発において重要なのか説明してください。
状態（State）が複雑になることで「UI とデータのズレ」が発生しやすくなり、
そのズレを防ぎ、整理されたアプリケーションを保つために状態管理が必要だから。

## 知識課題 2

Local State と Global State の違いを説明してください。

Local State とは（ローカルステート）:ある 1 つのコンポーネントの中だけで使う状態 → 他のコンポーネントには影響しない・見えない。

Global State とは（グローバルステート）:アプリ全体や複数のコンポーネントで共有する状態
→ ログイン状態・テーマ・言語設定など、「全体で知っておきたい情報」を管理。

スコープ
Local State:特定の 1 つのコンポーネント内で完結
Global State:アプリ全体や複数のコンポーネントで共有

管理対象
Local State:UI の一時的な状態（表示切替、入力フォームなど）
Global State:ユーザー情報、言語設定、カート情報など

状態の共有
Local State:他コンポーネントと共有できない
Global State:どのコンポーネントからでもアクセス・更新が可能

管理の簡単さ
Local State:簡単
Global State:やや複雑（ライブラリ導入や設計が必要な場合も）

使いどころ
Local State:UI 表示の切り替え、入力の保持など
Global State:ログイン情報、テーマ、共有データなど

主な使用方法
Local State:useState, useReducer
Global State:Redux, Recoil, Context API など

使用例
Local State:モーダルの開閉フラグ、フォーム入力の一時保持
Global State:ログインユーザー情報、アプリテーマ、カートの中身

Local State と Global State が、それぞれどのような場面で使われるのが適切か、具体例を挙げて説明してください。

Local State:
使用場面
• ユーザーの入力に応じて変わる一時的なデータ
• フォームの入力値
• モーダルの開閉状態
• ホバー状態やタブの切り替え

具体例：ユーザーが入力した文字をリアルタイムで記録してるフォーム
function LoginForm() {
const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
return (
< form>
< input value={email} onChange={e => setEmail(e.target.value)} />
< input value={password} onChange={e => setPassword(e.target.value)} />
< /form>
);
}

Global State:
適切な使用場面
• ユーザー認証情報（ログインユーザーの情報）
• アプリ全体で使うテーマ設定（ライト/ダークモード）
• ショッピングカートの中身
• 通知メッセージやアラートの状態

具体例：グローバルステートでユーザー情報を管理し、どこでも使えるようにしている。
const UserContext = createContext(null);

function App() {
const [user, setUser] = useState(null);

return (
< UserContext.Provider value={{ user, setUser }}>
< Header />
< Dashboard />
< /UserContext.Provider>
);
}

// Header.js
function Header() {
const { user } = useContext(UserContext);
return < p>Welcome, {user?.name}< /p>;
}

【自分用にまとめメモ】上記と被り部分
(疑問：Local State と Global State の書き方？なんか違いがわからないんだよね。
コードに直々 Local State って打ち込む訳じゃないし

項目 Local State（ローカルステート） Global State（グローバルステート）
どこで宣言？
Local State（ローカルステート）各コンポーネント内
Global State（グローバルステート）上位コンポーネント + Context や外部ライブラリ

読み方
Local State（ローカルステート）：useState()
Global State（グローバルステート）：useContext() や Redux など

共有範囲
Local State（ローカルステート）：そのコンポーネントだけ
Global State（グローバルステート）：複数のコンポーネントにまたがる

主な用途
Local State（ローカルステート）：フォーム、UI の一時状態
Global State（グローバルステート）：ログイン情報、カート、テーマ設定など)

## 知識課題 3

Local State のみでアプリケーションの状態を管理しようとすると、どのような問題が発生するか説明してください。

① 状態の「分断」や「重複」が起きる
同じようなデータ（たとえばログインユーザー情報やカートの中身）を、複数のコンポーネントがそれぞれ useState で別々に持ち始めてしまう。
問題点:
・状態がバラバラになる
・同じデータをあちこちで管理していて同期が取れなくなる
・更新漏れや不整合が起きやすい

② 深い階層に状態を渡すのが大変になる（プロップス地獄）
子 → 孫 → ひ孫と、状態や関数を props でどんどん渡していくことになる。
問題点
・コンポーネントの独立性が失われる
・可読性・保守性が下がる
・「渡すだけの中間コンポーネント」が増えてしまう

③ アプリ全体の状態を把握しにくくなる
状態がいろんなコンポーネントに散らばっていて、「どこに何があるのか」「どこが影響してるのか」把握しづらい。
問題点
・デバッグが面倒
・状態の変更がアプリ全体にどう影響するか見えにくい
・チーム開発で混乱が起きやすい

まとめ：Local State だけで頑張ると、状態がバラけて複雑になり、管理がしんどくなる。

Redux のようなグローバル状態管理を導入することで得られるメリットを説明してください。

1. 状態の一元管理でアプリ全体を把握しやすい
   ・すべての状態が「Store（保管所）」にまとめられる
   ・アプリ全体の状態を一目で確認・追跡しやすい

2. 複数コンポーネント間の状態共有が簡単にできる
   　・useSelector() や useDispatch() を使えば、どのコンポーネントからも状態を読み書きできる
   　・props のプロップス地獄から解放される

3. 状態の更新ロジックが集約できて予測しやすい
   　・状態の変更はすべて reducer に集約される
   　・データの流れがシンプルになり、意図しない副作用が起きにくい

4. テストがしやすい・再利用しやすい
   　・ロジックがコンポーネントから切り離されている
   　・reducer は純粋関数なので、テストが簡単

すべての状態を Global State で一元管理することのデメリットや危険性について考察し、説明してください。

1. パフォーマンス低下の原因になる
   ・Redux の Store の値が更新されると、その値を購読しているコンポーネントがすべて再レンダリングされる
   ・不必要に多くのコンポーネントが再レンダリングされると、アプリの動作が重くなる

2. 状態管理が過剰になり、開発が複雑化する
   ・簡単な状態でも毎回 Action と Reducer を書くのが面倒（特に Redux Toolkit 導入前の昔の Redux）
   ・小さな UI 状態（モーダルの開閉とか）までグローバルにすると、逆に読みにくくなる

3. アプリが巨大になるほど、Store が肥大化する
   ・すべての状態が一つの Store に集まると、構造が複雑になり、管理が困難になる
   ・ 「どこで使ってるの？」が分かりにくくなる

4. ロジックと UI の分離が逆に混乱を生むこともある
   ・コンポーネントから状態がなくなることで、直感的なコードが書けなくなる場合もある
   ・初学者にとっては敷居が高い（Redux 自体がちょっと難しめ）

アプリケーションの規模が大きくなるにつれて、Global State が肥大化すると、どのような問題が発生する可能性があるか説明してください。

① 関係ないコンポーネントまで再レンダリングされてしまう
Store の一部が変わっただけなのに、巨大な構造の中で広範囲の再レンダリングが発生することも。
問題点
• アプリが重くなる
• パフォーマンスが低下する
• スクロールや操作がカクつくことも

② Store（状態の倉庫）がカオスになる
あれもこれも Global State に突っ込んでいくと、状態の構造が複雑で巨大なオブジェクトになる。
問題点
• 状態の依存関係が分かりづらくなる
• どこで使ってるか追いにくい（=デバッグしにくい）
• 機能追加や変更のたびに影響範囲を探すのが困難

③ 型・命名・更新ロジックが破綻しやすい
ステートの数が増え、Action の数も増え、Reducer が増え、型定義（TypeScript など）も複雑になる。
問題点
• 型の矛盾が起きやすい
• Action 名がかぶる、意味がわかりにくい
• Reducer 関数が巨大化、1 つの switch 文で 100 行以上…など地獄化

④ 責務が曖昧になり、機能単位の切り出しが難しくなる
「なんとなく全部 1 個の store で管理しちゃってる」構成だと、各機能が依存しまくってスパゲッティ状態になる。
（スパゲッティ状態：機能やデータの依存関係が複雑に絡まりあっていて、何がどこに影響するのか分かりづらい状態のこと。）
問題点
• 機能ごとに切り分けてコンポーネントを独立させにくい
• モジュール性が下がり、チーム開発でコンフリクト多発
• 「この状態、何がいつ更新してるの…？」と誰も分からなくなる

⑤ 初期ロード時の処理やバンドルサイズが肥大化する
Store の初期状態が巨大 → ページ表示時に大量のデータをロードする必要あり。
全状態を 1 ファイルにまとめてると、JavaScript バンドルも大きくなる。
問題点
• ページ読み込みが遅くなる（UX 低下）
• モバイルや低スペック端末での体感が悪くなる

## 知識課題 4

Server Cache State/Form State/URL State が、それぞれどのような状態か説明してください。

Server Cache State（サーバーキャッシュステート）
サーバーから取得したデータ（例：API レスポンス）を、一時的にフロントエンドでキャッシュして保持する状態。
例：
• 商品一覧
• ユーザーのプロフィール情報
• 検索結果

Form State（フォームステート）
フォームに入力された一時的な値やバリデーションの状態など、ユーザーが操作中の情報を管理する状態。
例：
• 入力中の名前、メールアドレス、パスワード
• エラー表示（バリデーションエラー）
• 「送信中です」などの状態

URL State（URL ステート）
URL（クエリパラメータ・パス）によって表される状態。主に「今どこを見てるか」や「どんなフィルターをかけてるか」などを表す。
例：
• 検索キーワード：/search?q=react
• ページ番号：/products?page=2
• タブの切り替え：/settings/profile vs /settings/security

なぜこれらの状態を Global State とは区別する必要があるのか、それぞれの特性を踏まえて説明してください。

①Server Cache State：サーバーが「唯一の真実の情報源」
Global State で持ってしまうと…
• サーバーの更新と同期が取れない
• キャッシュ処理やリトライ、エラーハンドリングの実装が面倒
• 無駄にアプリ側に重い処理を抱え込む

別管理のメリット
• React Query や SWR などが自動でキャッシュ・再取得・エラー処理をやってくれる
• 必要なタイミングで自動リフェッチ
• “キャッシュのための状態”として専門的に扱える

②Form State：一時的でローカル、UI に密着した状態
Global State で持ってしまうと…
• 「送信ボタンが押されたらこのフォームがリセットされる」など、UI の振る舞いが他の場所にも影響してしまう
• 状態が複雑化・肥大化し、保守が面倒に

別管理のメリット
• useState や React Hook Form でフォーム専用の状態として完結
• 状態がスコープ内に閉じていて、再利用やリセットも簡単

③URL State：URL が状態を表す“見える化されたグローバル”
Global State で持ってしまうと…
• URL と状態が一致せず、“リロードしたら消えた”などの UX 崩壊
• 「共有できない状態」になる（URL コピーしても別の画面になる）

別管理のメリット
• React Router の useSearchParams などで URL と状態を自動的に同期
• 「状態＝ URL」なので、直感的にわかりやすい・再現性が高い

すべてを Global State に入れるのは、なんでも冷蔵庫に入れちゃうようなもの。
それぞれに合った収納場所（ツール・管理方法）を使うことで、アプリがシンプルで保守しやすくなる。
