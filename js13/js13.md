知識課題 1
スコープの基本的な概念と、その役割について説明してください。
スコープ（Scope）とは:変数や関数がどこで参照・使用できるのかを決めるルール。
変数がどこで有効なのか（アクセスできるのか）が、スコープによって決まる。
役割：不要な変数の競合を防ぎ、プログラムの安全性を保つ

グローバルスコープ/関数スコープ/ブロックスコープの特徴や用途を整理し、具体的なコード例を交えて解説してください。
グローバルスコープ
特徴:どこからでもアクセスできるスコープ。スクリプト全体に渡って有効。
用途:プログラム全体で使いたいデータを保管する時。

関数スコープ
特徴:関数の中で宣言した変数は、その関数内だけで有効。var で宣言すると、関数スコープになる。
用途:関数内で使う一時的な変数を定義する時。

ブロックスコープ:
特徴:{}で囲まれたブロック内で有効。let や const で宣言した変数がブロックスコープになる。
用途:条件分岐（if 文）、繰り返し（for 文）など、限られた範囲内で一時的な変数を使いたい時。

自分で感じた疑問：指定した変数によって勝手にスコープが切り替わるってこと？
答え：その理解であっています！変数を宣言するときに使うキーワード（var・let・const）によって、自動的にその変数が有効になる範囲（スコープ）が決まります。

スコープチェーンの概念について、仕組みと実際の動作を説明してください。
スコープチェーン（Scope Chain）とは：JavaScript が変数や関数を探すときにどの範囲から順に探していくかを決める仕組み。
内側 → 外側へと順番に変数を探す仕組み

仕組みの詳細
JavaScript で変数を使うとき、次の順番で変数を探す。
1,現在のスコープ（今いる場所）
2,ひとつ外側のスコープ
3,さらに外側のスコープ（グローバルまで繰り返す）
このように「内側 → 外側」の順番で探して、見つかった時点でそれを使う。
変数が見つかると、それ以上は探さない。見つからない場合はエラー。

const fruit = "りんご"; // グローバルスコープ(一番外側のスコープ)

function outerFunction() { // 関数 outerFunction を作成。この関数には outerFunction スコープという独自のスコープができる。

const fruit = "バナナ";
// outerFunction スコープ。その内にも変数 fruit を作り、「バナナ」を代入

function innerFunction() {
const fruit = "ぶどう";
// innerFunction スコープ。innerFunction という関数内にも fruit という変数を作り、「ぶどう」を代入。一番内側のスコープ
console.log(fruit); // 「ぶどう」を見つけて終了
}

innerFunction(); // "ぶどう"
}

outerFunction();
innerFunction() 内で fruit を探す
最初は内側（自分のスコープ）を探す
見つかった（ぶどう）ので、終了
外側の バナナ や りんご は無視される

※スコープは「見えない仕組み」であり、コードの中で直接的に『ここがスコープの境界だよ』という目印はない。しかし、スコープの境界は、以下のようにコード内の中括弧 {}（ブロック） で視覚的に見分けることができる。
const fruit = "りんご"; // グローバルスコープ

function outerFunction() { // 👈 ここからスコープ開始
const fruit = "バナナ"; // outerFunction スコープ（関数スコープ）

if (true) { // 👈 ここからブロックスコープ開始
const fruit = "ぶどう"; // ブロックスコープ
console.log(fruit); // 「ぶどう」
} // 👈 ここでスコープ終了

console.log(fruit); // バナナ
} // 👈 ここでスコープ終了

outerFunction();
console.log(fruit); // りんご

知識課題 2
関数宣言における巻き上げの概念を説明し、コードがどのような順序で解釈されるかを具体例を用いて明確に示してください。

関数宣言における巻き上げ(Hoisting ホイスティング)
JavaScript がコードを実行する前に関数の定義を先に読み込んでおき、
コード内で実際に関数が宣言される位置よりも前で、その関数が呼び出せるようになる仕組み。

sayHello(); // ここで先に関数を呼び出している（本来ならエラーになるはず）

// ここで関数宣言
function sayHello() {
console.log("こんにちは！");
}
結果：こんにちは！// あ、出るんだね？

？？なぜエラーが起きないか？？
関数宣言は、コードが実際に実行される前に（コンパイル段階で）内部的に巻き上げられ、どこからでも呼び出せるようになっているから。
(コンパイル段階とは:プログラムが実際に実行される前に、書かれたソースコード（人間が書いたコード）をコンピュータが理解できる形に変換する工程のこと)

JavaScript 側の視点だとこのコードを次のように解釈している：
// JavaScript が内部的に行う処理（イメージ）
function sayHello() { // ⬅️ 関数宣言を自動的に上に移動させる
console.log("こんにちは！");
}

sayHello(); // 問題なく呼べる（巻き上げのおかげ）

ただし、関数式（関数を変数に代入）だと巻き上げが起きない
巻き上げが起きるのは「関数宣言（function 宣言）」だけであり、関数式では巻き上げが起きない。
greet(); // エラーになる

const greet = function() {
console.log("こんにちは！");
};
この場合、関数は変数 greet に代入されるため、巻き上げは起きないらしい。

知識課題 3
クロージャーとは何か、その定義と内部でどのようにスコープが保持されるかについて解説してください。
クロージャー（closure）：関数の中でさらに関数を作ったときに、内側の関数が外側の関数のスコープにある変数を参照できる仕組み。(外側の関数の変数を、内側の関数が覚えておける仕組み)

function outer() {
let fruit = "りんご"; // 外側の関数の変数

// 内側の関数（クロージャー）
function inner() {
console.log(fruit); // 外側の変数を参照できる
}

return inner; // 内側の関数を返す
}

// 内側の関数を呼び出せる状態で取得
const closureFunction = outer();

// 外側の関数は終了したのに、"りんご"を覚えている
closure(); // 出力: りんご

なぜ重要？
外側の関数のスコープが終了しても、内側の関数（クロージャー）が外のスコープの変数を覚えておくため。

クロージャーを利用した具体的なコード例を提示し、クロージャーがもたらす利点について説明してください。

function createCounter() {
let count = 0; // 外側の関数で定義した変数（プライベート）

return function () {
count++;
return count;
};
}

// クロージャーを利用した関数を作成
const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

createCounter 関数の中で、count という変数を定義。
この count は createCounter の外側からは直接アクセスできない。（プライベート変数）。
内側で定義した関数が外側の変数 count を記憶（保持）している。
そのため、関数を何度も呼び出しても、count がリセットされずに増え続ける。

クロージャーの利点
変数を関数の外から変更される心配がなく、安全に状態を保つことができる。(プライベートな変数を実現できる)
状態を持つ関数を簡単に作れる。何回呼び出されたか、などの情報を外側の変数で管理できる。
変数の衝突（他の場所で同じ名前の変数を使っている場合）が防げる。
