知識課題 1
React コンポーネントにおける「副作用（エフェクト）」とは、具体的にどのような操作や処理を指しますか？説明してください。

ざっくり
React の「描画処理（＝レンダリング）」とは直接関係しないが、コンポーネントのライフサイクルに合わせて実行したい処理のこと。画面に表示するための「純粋な UI 表現」ではなく、それ以外の外部とのやり取りや副次的な処理。
(自分用：「表示に関係ないけど、やっておかないと機能しない処理」＝副作用！)

具体的にどのような操作や処理を指すか
1,API 通信/例：fetch()や axios などを用いて外部 API からデータを取得する処理。
2,イベント登録/ウィンドウのリサイズイベントやキーボード入力を監視する処理
3,タイマー操作/setTimeout や setInterval によって一定時間後に何かを実行する処理。
4,DOM 直接操作/ref.current.focus() を使って特定の入力欄にフォーカスを当てるなど。
5,ローカルストレージ読み書き/localStorage.getItem() などでデータを取得・保存する処理。
6,コンソールログ出力/console.log()で値や状態を確認する処理も、副作用に含まれることがある。

useEffect フックを使用せずに対応できる典型的なシナリオを 3 つ挙げてください。
それぞれのシナリオについて、なぜ useEffect が不要なのか、そして代わりにどのような React の機能やコーディングパターンを用いるべきかを具体的に説明してください。

① 入力フォームの状態管理（ユーザー入力に応じた表示）
入力欄に文字を入力したとき、それを画面に表示する。
onChange イベントと useState のみで リアルタイムに値が更新されるため、追加の副作用処理は不要。
代わりに使う機能・パターン：
• useState
• JSX 内での状態バインディング（value={state}）
(バインディング:値や動作（関数)を特定の場所や要素と結びつけること)
const [name, setName] = useState("");

return (
<>
< input value={name} onChange={(e) => setName(e.target.value)} />
< p>こんにちは、{name}さん< /p>
</>
);
「入力欄に名前を入れると、その名前を下にリアルタイムで表示する」仕組み

② 条件に応じた表示切り替え（state による UI 制御）
「詳細を表示する」ボタンで表示/非表示を切り替える・チェックボックスの ON/OFF
状態（state）の値を使って JSX 内で条件分岐できるから。
代わりに使う機能・パターン：
• useState
• 条件付きレンダリング（{condition && < Component />}）
const [show, setShow] = useState(false);

return (
<>
< button onClick={() => setShow(prev => !prev)}>
{show ? "隠す" : "表示"}
< /button>
{show && < p>これは詳細情報です< /p>}
</>
);
条件付き表示の切り替えパターン

③ 派生データの計算（入力値から計算される表示など）
数字を 2 倍にして表示する・入力されたパスワードが 8 文字未満かどうかを表示する
useEffect を使わなくても、state を使った計算結果を JSX に直接書くだけで済む。

代わりに使う機能・パターン：
• useState（元データ）
• const derived = num \* 2 のような JSX 直前での算出処理

const [num, setNum] = useState(0);
const doubled = num \* 2;

return (
<>
< input type="number" onChange={(e) => setNum(Number(e.target.value))} />
< p>2 倍の値：{doubled}< /p>
</>
);
派生データのリアルタイム表示パターン

知識課題 2
useEffect フックに渡された関数（エフェクト）が、コンポーネントのライフサイクルにおいて主にどのタイミングで実行されるか、代表的なタイミングを説明してください。

(コンポーネントのライフサイクルって？：React コンポーネントが生まれて、表示されて、消えるまでの流れ（人生の流れ）のことを「ライフサイクル」って呼ぶ。
[1] 生まれる（マウント） → [2] 状態が変わる（更新） → [3] 消える（アンマウント）)

・初回マウント後/初回描画直後に 1 回だけ実行される/依存配列の書き方:[]
・特定の値が変化したとき/指定した state や props が更新されたタイミングで実行/依存配列の書き方[依存変数]
・アンマウント時/コンポーネントが破棄される前にクリーンアップ処理が実行される/依存配列の書き方:return () => { ... } の形式で関数内に書く
(アンマウント:React コンポーネントが画面から消えること)
(クリーンアップ処理:コンポーネントがアンマウント（画面から消える）直前や、useEffect が再実行される前に行う“お片付け処理)

useEffect の第二引数として渡される依存配列（dependencies）の役割とその重要性について説明してください。

第二引数の依存配列（dependencies）
useEffect(() => {
// 副作用の処理
}, [依存値]);ここで [] の中に入っているのが 「依存配列」。
この配列は、「どの値が変化したときにこの useEffect を再実行するか」を React に伝える役割がある。

少し詳しく
useEffect(() => {
console.log("count が変わったよ！");
}, [count]);
この例では count が変わったときだけ、useEffect の中の処理が実行される。

重要性：
① 無限ループを防ぐため
依存配列を書かないと、useEffect が毎回再レンダリング時に実行されてしまい、無限ループになることがある。

② 効率的に副作用を管理するため
「変化したときだけ処理したい」ものを明確にすることで、無駄な処理や通信を避けられる。

③ バグの予防になる
依存すべき値を明記することで、「意図しない再実行や再描画」を防ぎ、動作が安定する。

useEffect の依存配列について、以下の各場合でエフェクト（第一引数の関数）が再実行される条件の違いを説明してください。
a. 依存配列が空 ([]) の場合：初回マウント時のみ（＝コンポーネントが最初に表示されたとき）
b. 依存配列に特定の依存値 ([value1, value2]など) が含まれる場合：依存配列の中にあるいずれかの値が変化したとき
c. 依存配列が省略された場合：コンポーネントが再レンダリングされるたびに必ず実行される

useEffect の第一引数の関数から返される「クリーンアップ関数」の目的と実行されるタイミングについて、具体例を挙げて説明してください。
クリーンアップ関数とは：副作用の「お片付け処理（後始末）」を定義する関数のこと。
useEffect の中で return () => { ... } と書くことで指定できる。

目的
1,無駄な処理を止める/タイマー・イベントリスナーなどを 解除して、動き続けないようにする
2,メモリリークを防ぐ/コンポーネントが消えた後も不要な処理が残るのを防ぐ
(メモリリーク:本来解放されるはずのメモリ（使わなくなったデータや処理）が残り続けてしまう現象)
3, 意図しない重複を防ぐ/状態更新や API の再実行が 重複しないように管理する

クリーンアップ関数が実行されるタイミング
① コンポーネントがアンマウントされる時
画面から消えるタイミング（例：ページ遷移や表示の切り替え）

例：setInterval（タイマー）を止める
useEffect(() => {
const timer = setInterval(() => {
console.log("1 秒ごとに動く！");
}, 1000);

return () => {
clearInterval(timer); // ← クリーンアップ：止めないと永遠に動く
console.log("タイマー止めた！");
};
}, []);
マウント時 → タイマー開始
アンマウント時 → クリーンアップ関数でタイマー終了

知識課題 3
ユーザー操作に直接反応するロジック（イベントハンドラ）と、レンダリングや状態変化に応じて同期するロジック（エフェクト）を分離することが推奨される理由を説明してください。

イベントハンドラ（ユーザー操作に反応する処理）
エフェクト（レンダリングや状態変化に反応する処理）

① 役割が異なるから
イベントハンドラ:ユーザー操作にすぐ反応/クリック、入力、ホバーなど
エフェクト:描画や状態の変化に応じて処理を実行/マウント・更新・アンマウント時など
それぞれ「いつ・なぜ動くか」が全く違うため、分けておかないと混乱しやすい。

② 予測しやすくなる（バグを防ぐ）
ユーザー操作に関する処理が useEffect に混ざっていると、いつ実行されるかがわかりづらくなる。
意図しないタイミングで実行されることがある（再レンダリングなど）
ロジックの責任範囲がごちゃまぜになると、再利用しづらく、メンテナンスもしにくくなる

一言で言うと「誰かに押されたボタン」と「それを見て自動で動く仕組み」を混ぜるな、という話！
これらを分離することで、コードの可読性・予測性・保守性が大きく向上

イベントハンドラのロジックとエフェクトのロジックを分離するための、具体的なコード構成やパターンを説明してください。

このように分ける
イベントハンドラ:
書く場所:onClick や onChange など
役割:状態を「変える」ための処理（ユーザー起点）

エフェクト
書く場所:useEffect
役割:状態や描画に応じて「動く」処理（システム起点）

責任を分離
import { useState, useEffect } from "react";
// React から フックである useState（状態管理）と useEffect（副作用管理）をインポート

function UserFetcher() {
const [userId, setUserId] = useState(null);
const [userData, setUserData] = useState(null);

// ボタンが押されたら「状態だけを変更」
const handleFetchClick = () => {
setUserId(1); // ユーザー ID を設定（トリガー）ボタンがクリックされたときに呼ばれる関数（イベントハンドラ）
};

// 状態が変わったら「エフェクトで API 呼び出し」
useEffect(() => {
if (userId === null) return;//（副作用処理）

    fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
      .then((res) => res.json())
      .then((data) => setUserData(data));

}, [ userId]);

return (
< div>
< button onClick={handleFetchClick}>ユーザー情報を取得< /button>
{userData && < p>{userData.name} さん< /p>}
< /div>
);
}

useEffect の依存配列から不要な依存値（実際にはエフェクトの実行条件に関係ない値）を取り除くことが重要な理由を説明してください。
useEffect の 依存配列に「関係ない値（不要な依存）」を入れてしまうと、パフォーマンスや動作の安定性に悪影響を与えることがある。

①：無駄な再実行を防ぐため
依存配列に本来関係のない値を入れてしまうと、
その値が変わるたびに useEffect が無駄に実行されてしまう。
その結果：API の再取得が不要なのに何度も行われる。アニメーションが何度も発火して不自然になる。

②：パフォーマンス低下・リソース浪費につながる
不要な副作用処理（たとえばデータ取得やイベントリスナーの登録など）が実行されると、
CPU・ネットワーク・メモリなどのリソースを無駄に消費することになる。

特に、タイマーやサブスクリプション処理などが何度も作り直されると、
メモリリークや処理の重複による不具合が起こる可能性もある。

③：クリーンアップ処理が無駄に繰り返される
(クリーンアップ処理:コンポーネントがアンマウント（画面から消える）直前や、useEffect が再実行される前に行う“お片付け処理)
依存配列に関係のない値が含まれていると、
その値の変化によって 再実行とクリーンアップが無意味に繰り返されてしまうことがある。
その結果：イベントリスナーの 登録・解除が頻繁に繰り返される・タイマーが止めては再起動される

不要な依存値を取り除くための具体的なテクニックをいくつか挙げ、それぞれがどのように依存関係の削減に役立つのか説明してください。

1. useCallback で関数をメモ化する
   なぜ？
   関数は毎回再生成されるため、依存配列に含めると useEffect が毎回実行されてしまう。

どう役立つ？
useCallback で関数をメモ化すれば、依存値が変わらない限り同じ参照を保てるため、無駄な再実行を防げる。
const fetchData = useCallback(() => {
// データ取得処理
}, []); // 安定した参照

2. useMemo でオブジェクトや配列をメモ化する
   なぜ？
   オブジェクトや配列リテラルも毎回新しく生成されるので、依存に含めると常に変化したと認識される。

どう役立つ？
useMemo を使えば、依存が変わらない限り、同じオブジェクトや配列が使われるようになる。
const options = useMemo(() => ({ limit: 10 }), []);

3. 実際に使っていない変数は依存配列に含めない
   なぜ？
   副作用内で使っていない変数を依存に含めると、意味のない再実行が発生してしまう。

どう役立つ？
本当に使っている値だけに限定することで、意図しない挙動を防げる。
// 無意味な依存を入れない
useEffect(() => {
doSomething(); // count を使ってない
}, [count]); // → 不要なら外す

4. 変化しない定数や固定値は依存から除外する
   なぜ？
   グローバル定数や初期化時に一度だけ使われる値は、依存に入れても意味がない。

どう役立つ？
ESLint の警告を無視してでも除外することで、無駄な副作用の実行を抑えられる。
const API_URL = "https://api.example.com";

useEffect(() => {
fetch(API_URL);
// eslint-disable-next-line react-hooks/exhaustive-deps
}, []); // ← API_URL は変化しないので依存不要
