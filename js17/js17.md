知識課題 1
同期処理と非同期処理の概念を調査し、それぞれの違いを説明してください。
同期処理（synchronous（シンクロナス））
非同期処理（asynchronous（アシンクロナス））

実行順序
同期処理:上から順番に処理される
非同期処理:後回しの処理があっても次に進む

待ち時間
同期処理:待つ（次に進まない）
非同期処理:待たない（同時進行できる）

実用例
同期処理:計算・画面描画など
非同期処理:タイマー、API 通信、データ取得など

メリット
同期処理:シンプルで直感的
非同期処理:効率的に動作できる（画面が固まらない）

デメリット
同期処理:時間がかかると止まる
非同期処理:処理が「いつ終わるかわからない」ので複雑になりがち

ブラウザで同期的な処理（同期的なブロック処理）を行うと、どのような問題が発生するか具体的にまとめてください。

シングルスレッド（一度に 1 つしか処理できない）という特性がある為、
ブラウザで同期的な処理を使いすぎると、画面が固まって操作できなくなる。
具体的な問題
画面がフリーズし、ボタンを押しても反応せず、スクロールもできない状態になる。
データ読み込み中(ローディング中)、表示が止まり固まったように見えてしまう。
テキストを打っても反映されない、クリックも無反応になる。
ブラウザが「応答していません」と表示することもある（重いループなどで）
例：
// ブラウザがフリーズする例（重い計算）
for (let i = 0; i < 1e9; i++) {
// ただ回すだけでも重い
}
console.log("終わった！");//連打で実行したら、確かに重い

知識課題 2
Promise の基本的な仕組みを調査し、次の用語を用いて Promise の状態遷移を説明してください。

pending/fulfilled/rejected
Promise.resolve/Promise.reject

Promise（プロミス）：Promise は、非同期処理の「成功」や「失敗」の結果を、あとから受け取るための仕組み。
基本構文：
const promise = new Promise((resolve, reject) => {
// 非同期処理をここに書く
});この new Promise(...) の中で、成功すれば resolve()（リゾルブ）, 失敗すれば reject() （リジェクト）を呼び出すことで
Promise の状態を変えることができる。

その中に 3 つの状態（ステータス）があり、pending、fulfilled、rejected がある。
pending(ペンディング)：保留中。(初期状態。まだ結果が決まっていない。)
fulfilled(フルフィルド)：成功！(resolve() が呼ばれた状態)
rejected(リジェクテッド)：失敗！(reject() が呼ばれた状態)

Promise.resolve： 成功した状態の Promise を作る（fulfilled）
Promise.reject ：失敗した状態の Promise を作る。（rejected）
上記二つは「すでに結果が決まった Promise を簡単に作る方法」

Promise.prototype.then および Promise.prototype.catch の役割と使い方を整理してください。
Promise の「成功」や「失敗」に応じて処理をつなぐためのメソッド
Promise.prototype.then()Promise が 成功（fulfilled） したときに成功時の処理をつなぐ
Promise.prototype.catch()Promise が 失敗（rejected） したときエラー処理を行う

Promise.prototype.catch を用いたエラーハンドリングの仕組みについてまとめ、例外（throw）と Promise を組み合わせる際の注意点を具体的に挙げてください。

エラーハンドリングの仕組み：catch() は、Promise が rejected（失敗） になったときに実行される関数を登録する。

Promise.reject("エラーが発生しました")
.catch((err) => {
console.error("❌ キャッチ:", err);
});
エラーが reject() された場合、catch() に渡した関数で処理

例外（throw）との組み合わせで注意すべき点.then()の中で throw を使うと、自動的に rejected 状態になり、次の.catch()で処理される。
一方 try...catch では Promise.reject() のような非同期エラーは補足できない。
つまり、非同期エラーは.catch()を使って処理するのが正しい。

知識課題 3
Promise チェーンの意味を説明し、どのように書くことで可読性や保守性が向上するか考察してください。
Promise チェーン:Promise の .then() を連続してつなげて書くこと。
1 つの非同期処理が終わったあとに、次の処理を順番に実行していく構文。
(簡単にいうと、非同期処理（時間がかかる処理）を順番にキレイにつなげて書く方法のこと)

Promise チェーンを使った書き方
getUserId()
.then((id) => getUserProfile(id)) // ユーザー情報取得
.then((profile) => updateUI(profile)) // UI 更新
.catch((err) => console.error("エラー:", err)); // どこかでエラーが出たらまとめてキャッチ

• getUserId()：最初の非同期処理
• then(...).then(...)：処理が順に連なっている
• catch()：どこかで失敗しても、ここでまとめて処理できる

これが Promise チェーンと呼ばれる書き方。

.then() を連結して使うことで、処理の順番がはっきり見えるようになり、
コールバックの入れ子（callback hell）を避けて、コードの見通しが良くなる。
上から下に「流れ」が見えるから、「何を、どの順でしてるか」がパッとわかる。
また、それぞれの処理が独立しているため、後から一部を修正・差し替えしやすく、保守性も高い。

Promise.all と Promise.race はそれぞれどのような場面で役立つのか、特徴や使い分けのポイントを説明してください。

どちらも複数の Promise（非同期処理）をまとめて扱うための便利なメソッド。

Promise.all()
特徴：複数の Promise がすべて成功（fulfilled）するのを待ってから、次の処理をする。どれか 1 つでも失敗（rejected）すると、全体が rejected になる。
すべての非同期処理が完了してから処理したいときに使用。
複数の API からデータを取得して、一緒に画面に表示したい場合や、複数の画像を同時に読み込んでから表示したい場合。

const p1 = fetch("/api/user");
const p2 = fetch("/api/posts");
const p3 = fetch("/api/comments");

Promise.all([p1, p2, p3])
.then(([res1, res2, res3]) => {
// 全部成功したらここでまとめて処理！
console.log("全て取得完了");
})
.catch((err) => {
// どれか 1 つでも失敗したらここにくる
console.error("1 つでも失敗:", err);
});

Promise.race():
特徴:複数の Promise の中で、最初に終わったもの（成功でも失敗でも）だけを返す。一番早く settle（完了）したものが勝ち！
どれか 1 つが終わった時点で結果が欲しいとき

const slow = new Promise(resolve => setTimeout(() => resolve("遅い"), 3000));
const fast = new Promise(resolve => setTimeout(() => resolve("速い"), 1000));

Promise.race([slow, fast])
.then(result => {
console.log(result); // → "速い"
});

タイムアウト処理「3 秒以内に終わらなかったら中断」や
複数の API に同時にリクエストを投げて、最初に返ってきたものを採用したいときなどに使用。

知識課題 4
Async Function と await 式のそれぞれの概念を調査し、基本的な使い方を整理してください。

Async Function(アシンク ファンクション)(async は非同期の略)
async をつけた関数は 常に Promise を返す。関数内で await を使うことができる。
関数の前に書く

async function 関数名() {
// 非同期処理が書ける
return "結果";
}

await(アウェイト)(待つ、待機する)
await は Promise が解決（resolve）されるのを待つキーワード。
await は 必ず async 関数の中でしか使えない。

async function getData() {
const result = await fetch("/api/data");
const json = await result.json();
return json;
}
fetch() の完了を 一時停止して待ってから 次の行に進んでいる。

従来の Promise を使った方法と比べ、Async Function と await 式を用いることで、コードの可読性やエラーハンドリングがどのように向上するのか考察してください。

読みやすさ
Promise（.then）:ネスト・チェーンが長くなりがち(関数や処理が中に中に入り込むように書かれている状態のこと)
async/await:同期処理のように直感的に書ける

エラーハンドリング(エラーが起きたときに、止まらずにどう対処するか？を決めておく仕組み)
Promise（.then）:.catch() を使うが分散しやすい
async/await:try...catch で 1 か所にまとめられる

保守のしやすさ
Promise（.then）:分岐や条件が複雑になると読みづらい
async/await:流れが自然で追いやすくなる

async/await を使うことで、非同期処理が人間にも読みやすいコードになる。
エラー処理も自然な形で書けるから、安心してバグの少ないコードが作れるようになる。
