知識課題 1
クラスとは何か、その定義方法について調査し、JavaScript のサンプルコードを用いて説明してください。
オブジェクトを作成するためのテンプレート(設計図)のようなもの。

JavaScript のサンプルコード
// Human クラスの定義
class Human {
// コンストラクター（オブジェクトの初期化）
constructor(name, age) {
this.name = name; // プロパティ設定
this.age = age; // プロパティ設定
}

// メソッド（行動）
greet() {
console.log(`こんにちは！私の名前は${this.name}です。${this.age}歳です。`);
}
}

// クラスを使ってオブジェクト（インスタンス）を作成
const taro = new Human("太郎", 25);
const hanako = new Human("花子", 30);

// 作成したオブジェクトのメソッドを実行
taro.greet(); // こんにちは！私の名前は太郎です。25 歳です。
hanako.greet(); // こんにちは！私の名前は花子です。30 歳です。

インスタンスの概念および、クラスからのインスタンス生成手順を、具体的なコード例とあわせて解説してください。
インスタンス：クラス（設計図）を元に作られた具体的なオブジェクト（実体）のこと。
（クラスが車の設計図だとすると、インスタンスは「赤いスポーツカー」などの具体的な車。）
例：
// クラスの定義
class Car {
constructor(brand, color) {
this.brand = brand; // 車のブランド
this.color = color; // 車の色
}

// メソッド（動作を定義）
drive() {
console.log(`${this.color} の ${this.brand} が走っています！`);
}
}

// `new` を使って"インスタンス"を生成
const myCar = new Car("Toyota", "赤");
const yourCar = new Car("Honda", "青");

// インスタンスのメソッドを呼び出す
myCar.drive(); // "赤 の Toyota が走っています！"
yourCar.drive(); // "青 の Honda が走っています！"

クラスのプロトタイプメソッドとアクセッサプロパティの役割や利用例を、実際のコードを示しながら説明してください。
プロトタイプメソッド:クラスのすべてのインスタンスで共有できるメソッド
クラス内で通常のメソッドとして定義すると、自動的にプロトタイプメソッドになる。

①
プロトタイプメソッドのコード例
// クラスの定義
class Person {
constructor(name, age) {
this.name = name;
this.age = age;
}

// プロトタイプメソッド（インスタンスが共有）
greet() {
console.log(`こんにちは、私は ${this.name} です！`);
}
}

// インスタンスを作成
const person1 = new Person("太郎", 25);
const person2 = new Person("花子", 30);

person1.greet(); // こんにちは、私は 太郎 です！
person2.greet(); // こんにちは、私は 花子 です！

プロトタイプメソッドを使う利点
すべてのインスタンスでメソッドを共有できる。
メモリの節約になる（各インスタンスごとにメソッドをコピーしない）

②
アクセッサプロパティ: プロパティを取得 (getter) や設定 (setter) する際にカスタムの処理 を追加できる特別なメソッド。

class Person {
constructor(name, age) {
this.\_name = name; // `name` は `getter` / `setter` を使うので、`_name` に保存
this.age = age;
}

// `getter` で `name` を取得する
get name() {
return this.\_name.toUpperCase(); // 名前を大文字に変換して返す
}

// `setter` で `name` を設定する
set name(newName) {
if (newName.length > 1) {
this.\_name = newName;
} else {
console.log("名前は 2 文字以上で設定してください。");
}
}
}

// インスタンス作成
const person = new Person("Taro", 25);

// `getter` を使って `name` を取得
console.log(person.name); // "TARO"（大文字で表示）

// `setter` を使って `name` を変更
person.name = "Hanako";
console.log(person.name); // "HANAKO"

// 1 文字の名前を設定しようとするとエラー
person.name = "A"; // 名前は 2 文字以上で設定してください。

難しい。
アクセッサプロパティを使用する利点
プロパティの値に制約をかけられる（バリデーションができる）
取得時にデータを加工できる（例：大文字変換）
セッターを使って値の設定方法を統一できる

知識課題 2
public（パブリック） クラスフィールドと private（プライベート） クラスフィールドの違いについて、具体例を用いて詳細に説明してください。

アクセス範囲
public（公開）：クラスの外部からもアクセス可能
private(非公開)：クラス内部でのみアクセス可能

記述方法
public（公開）：this.name = value; or name = value;
private(非公開)：#name = value;

外部からの変更
public（公開）：直接変更可能
private(非公開)：直接変更不可（getter/setter が必要）

データの安全性
public（公開）：低い（勝手に変更できる）
private(非公開)：高い（不正な変更を防げる）

利用例
public（公開）：name, color など自由に変更可能なプロパティ
private(非公開)：password, ID など外部から変更されたくないデータ

クラスフィールド内での this が、どのようにインスタンス自身を指すのかを示すコード例を作成し、解説してください。

this：クラスフィールドやメソッド内で、インスタンス自身を指す特性

class Person {
// クラスフィールド（Public）
name = "匿名";
age = 0;

constructor(name, age) {
// `this` は生成されたインスタンスを指す。
this.name = name;
this.age = age;
}

// メソッド
introduce() {
console.log(`こんにちは、私は ${this.name} です。${this.age} 歳です！`);
}
}

メモ：
this.name = name;は現在のインスタンス (person1 や person2) を指す。
各インスタンスごとに name や age を独自の値に設定 できる。

メソッド内の this.name は introduce() メソッド内で this.name を使うと、そのメソッドを呼び出したインスタンスの name を参照。
person1.introduce(); を実行すると、this.name は "太郎" になる。

// インスタンスを作成
const person1 = new Person("太郎", 25);
const person2 = new Person("花子", 30);

// メソッドを呼び出し
person1.introduce(); // "こんにちは、私は 太郎 です。25 歳です！"
person2.introduce(); // "こんにちは、私は 花子 です。30 歳です！"

知識課題 3
静的メソッドと静的クラスフィールドの定義方法について、JavaScript のサンプルコードを作成しながら、それぞれの特徴を整理してください。

クラスでは、static キーワードを使うことで、インスタンスではなくクラス自体に属するメソッドやフィールドを作成できる

静的メソッド（static method 　スタティック メソッド）：クラスに直接関連する処理を定義する（インスタンスではなくクラスから呼び出す）
定義方法：static methodName() { ... }

静的クラスフィールド（static field スタティック フィールド）：クラスに属する変数として機能（全インスタンスで共通）
定義方法：static fieldName = value;

静的メソッド（static method）：
class MathUtil {
// 静的メソッド（static method）
static add(a, b) {
return a + b;
}

static multiply(a, b) {
return a \* b;
}
}
// **クラスから直接呼び出す**
console.log(MathUtil.add(5, 3)); // 8
console.log(MathUtil.multiply(4, 2)); // 8

// **インスタンスからは呼び出せない**
const mathInstance = new MathUtil();
// console.log(mathInstance.add(5, 3)); // エラー（静的メソッドはインスタンスから呼べない）

静的クラスフィールド（static field）
class Settings {
// 静的クラスフィールド（static field）
static appName = "MyApp";
static version = "1.0.0";

// 静的メソッドでフィールドを利用
static getAppInfo() {
return `${this.appName} - Version: ${this.version}`;
}
}

// **クラスから直接アクセス可能**
console.log(Settings.appName); // "MyApp"
console.log(Settings.version); // "1.0.0"

// **静的メソッドで情報を取得**
console.log(Settings.getAppInfo()); // "MyApp - Version: 1.0.0"

// **インスタンスからはアクセスできない**
const settingsInstance = new Settings();
// console.log(settingsInstance.appName); // エラー（静的フィールドはインスタンスから使えない）

知識課題 4
クラスの継承の概念および、継承したクラスを定義する方法を、コード例を用いて説明してください。

クラスの継承（Inheritance・インヘリタンス）：既存のクラス（親クラス）を元にして、新しいクラス（子クラス）を作成する仕組み.extends を使ってクラスを継承

class ParentClass {
constructor(name) {
this.name = name;
}

greet() {
console.log(`こんにちは、私は ${this.name} です！`);
}
}

// ParentClass を継承する
class ChildClass extends ParentClass {
constructor(name, age) {
// `super()` を使って親クラスのコンストラクタを呼ぶ
super(name);
this.age = age;
}

introduce() {
console.log(`私は ${this.name} で、${this.age} 歳です！`);
}
}

// **インスタンスの作成**
const child = new ChildClass("太郎", 25);

child.greet(); // こんにちは、私は 太郎 です！ （親クラスのメソッド）
child.introduce(); // 私は 太郎 で、25 歳です！ （子クラスのメソッド）

super キーワードが親クラスのプロパティやメソッドをどのように利用するか、具体的なコード例を添えて解説してください。

super キーワード：親クラス（スーパークラス）のコンストラクタやメソッドを呼び出すために使用。
super(name)：親クラスのコンストラクタを実行できる。
親クラスのプロパティ name を継承しつつ、子クラス独自のプロパティ を追加できる。

(コンストラクタ（constructor）：クラスからインスタンスを生成するときに自動的に実行される特殊なメソッド.インスタンスのプロパティを初期化する・クラスを元にオブジェクトを作成するときに必要な処理を実行する)

super() を使って親クラスのコンストラクタを呼び出す場合
// 親クラス（Super Class）
class Animal {
constructor(name) {
this.name = name; // 親クラスのプロパティ
}

greet() {
console.log(`こんにちは、私は ${this.name} です！`);
}
}

// **子クラス（Sub Class）**
class Dog extends Animal {
constructor(name, breed) {
// **親クラスのコンストラクタを呼び出す**
super(name);
this.breed = breed; // 子クラス固有のプロパティ
}

introduce() {
console.log(`私は ${this.name} で、犬種は ${this.breed} です！`);
}
}

// インスタンスを作成
const myDog = new Dog("ポチ", "柴犬");

myDog.greet(); // "こんにちは、私は ポチ です！"（親クラスのメソッド）
myDog.introduce(); // "私は ポチ で、犬種は 柴犬 です！"（子クラスのメソッド）

※これは別でコードの深掘りは必要だ。難しい
